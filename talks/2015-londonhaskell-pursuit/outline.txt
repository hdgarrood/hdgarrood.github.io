
===
slide 3

What problem?
- There is a lot of reusable PureScript code available as libraries
- We want to make it accessible and discoverable.
Questions like:
- How do I use this library?
- What can I do with a value of type X? What does it represent?
- What does the function Y do?
- Does any function with the type Z exist?
- Has anyone written code to help deal with, eg, nonempty arrays?

First started wondering while writing multiplayer pacman
- Documentation was hard to find
- Often Google was your best bet
  - only for package names, not function / module / type
- Easy to reimplement/not use things that already exist
  - eg: mconcat, intercalate, non-empty arrays

===

At the time, pursuit was mostly client-side and written in PureScript. There
was a Haskell program which took a list of files on standard input, parsed
them, and generated a JSON file with a list of entries: that is, a tuple:
(module, name, type). Then the client-side application started by fetching
that, building a database (in fact a trie), and then displayed an <input>
element that would react to changes by displaying relevant entries below it.

problems:
- Required human input to regenerate, so regeneration was dependent on Phil
  having enough free time.
- Wasn't able to tell you which package something came from, had no concept of
  packages
- Very basic name search: eg, wanted to search for suffixes, and Phil made
  suffixes branch, but then the trie became too large to be practical
- No type search
- Separate from documentation; results might not line up with docs on GitHub,
  since versions can drift apart.

===

Next: Generate data from a list of libraries; automate the database rebuilding.
Probably my first contribution. Created a libraries JSON file, which would list
all the libraries that should be included and where to get them, and set up a
cron job to periodically recreate the resulting JSON data file.

Another nice thing was that this introduced the notion of libraries as well as
including information about the github repository that they came from, which
meant that we could then display that in the output.

problems:
- syntax, please don't make humans edit JSON
- error reporting; when the job runs automatically on a server, it's difficult
  to report errors, not just to the administrator of the server (because
  relying on remembering to check the logs is a non-starter), but even more to
  the library authors whose libraries weren't building.
- a database regen was either succeed or fail: even if all but one libraries
  could be generated successfully, if the last didn't build, then the database
  wouldn't be updated. Debugging these was annoying and time-consuming; we had
  one because of:
  - unicode in a source file
  - Data.Text.IO using environment variables
  - Upstart fiddled with these variables
  This meant that we had long periods with no updates.

===

Next iteration: move the database + querying to server-side, in Haskell. Very
basic scotty application that had just one route, which would take a query
as a part of the query string, and return a list of matching entries as JSON.

Problems:
- Search now even more basic (= exact match)

===

Where we are now:

- HTML documentation
  - (show in browser)
  - package overview pages
  - Links to dependencies is great
    - mention bug re transitive dependencies
  - Titles for fully-qualified names
  - Source links on GitHub
  - Markdown via Cheapskate. Doesn't seem to be a problem (yet) that we use two
    different renderers.
  - Only shows published versions, no risk of accidentally looking at master
    docs

- Github integration
  - (show 'published by')
  - accounts as identities (so that we know who uploaded stuff)
  - OAuth
  - Displaying READMEs
  - source links
  - backup
- Pros
  - easy deployment
  - no sensitive data on the server
  - easy implementation
- Cons
  - if Github goes down, no uploading because impossible to authenticate

- Hoogle
  - (show: "s (t a) -> t (s a)")
  - Good searching by name and type :)
  - How does it work?
    - Store an intermediate form of data, similar to an AST, containing
      modules -> declarations, with type (both senses), title, docs, etc.
    - Go over all the packages, turning this into a Hoogle input file
      - To do this, we have to pretend it's Haskell:
        - fiddle with rows, turn them into weird haskell-ish types
        - flip arrows around in type class declarations
    - Give that to Hoogle, create a database
    - This all takes around 5 seconds for the whole database at the moment
    - Stick it in a TVar, regenerate hourly
    - Finally, take queries from the web UI and pass them to Hoogle
  - Although a couple of problems with type search
    - 500 errors because I wasn't interpreting Hoogle output correctly
    - Thinks two identically named data constructors in different modules are
      the same
    - No results for the following:
      - Char -> String
      - Map k v -> List (Tuple k v) 
  - Rows are hideous
    - (show)

- Filesystem database
  - JSON files, in the same structure
  - Potentially going to bite us later on
    - "Three options, Postgres, SQLite, intense pain"
  - But it seems ok so far
  - Backup is super easy: just git commit and push to GitHub.
  - The only configuration necessary is to specify a directory to use
  - Also: very easy to duplicate production DB for development

===

In the future

- Automated uploading
- Better Hoogle integration
  - first class PureScript support

Todo?
- What integrating with Hoogle is like?
- What using Yesod is like?
- Differences to Hackage?
- Strong integration with GitHub: advantages, disadvantages.
