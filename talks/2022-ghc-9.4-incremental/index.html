<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="x-ua-compatible" content="ie=edge">
    <script type="text/javascript" src="reveal.js"></script>
    <link rel="stylesheet" type="text/css" href="reveal.css">
    <link rel="stylesheet" type="text/css" href="style.css">
    <title>Easy incremental CI builds with GHC 9.4</title>
  </head>
  <body>
    <div class="reveal">
      <div class="slides">
	<section id="title">
	  <h1>Easy incremental CI builds with GHC 9.4</h1>
	  <h3>Harry Garrood</h3>

	  <!--
	    Hi, and thank you for coming to my talk. I'm going to tell you about
	    how I significantly sped up our Haskell CI builds at Mercury and how
	    you can probably do the same.
	  -->
	</section>

	<section id="1">
	  <h2>We spend a huge amount of time recompiling the same code in CI over and over again.</h2>
	  <h1>What if we stopped doing that?</h1>
	  <!--
	    This has probably occurred to some of you before. We spend a
	    huge amount of time recompiling the same code in CI over and
	    over again.

	    Why should I have to wait for 3000 modules to compile in CI
	    when my changes only affect 100 of those modules?

	    How much time and energy have we cumulatively been wasted due
	    to unnecessary recompiles? To me, it's almost an embarrassment
	    that we collectively put up with this.
	  -->
	</section>

	<section id="2">
	  <h1>Ok, well, let's just cache our build products.</h1>
	  <!--
	    So the next thing you might think is, okay, well GHC already
	    has a perfectly good incremental build system built-in right?
	    GHC does indeed have a very impressive incremental build system
	    built in - in addition to preventing unnecessary recompiles, it
	    also implements "cutoff", where if a module's interface hasn't
	    changed, then downstream modules won't be rebuilt. It's
	    actually really good and I think it deserves more credit. You
	    probably take advantage of this locally all the time when
	    you're working on Haskell projects.

	    Ok great - so, if we want incremental builds in CI, let's just
	    keep our build products around, like we do locally, and see
	    what happens.
	  -->
	</section>
	<section id="3">
	  <h2>Ok, well, let's just cache our build products.</h2>
	  <h1>Wait, everything is still getting rebuilt. What?</h1>
	  <!--
	    Unfortunately, before GHC 9.4, there was one fatal flaw in
	    GHC's recompilation checking that made it near useless in CI
	    environments.
	  -->
	</section>

	<section id="4">
	  <h1>Source file change checking</h1>
	  <ul>
	    <li>GHC needs to figure out which files have changed since the last build, so that it knows what to rebuild</li>
	    <li>In GHC 9.2 and earlier, this was implemented by comparing the timestamps of each source file and its corresponding object file; if the object file is newer, the file is considered up to date.</li>
	    <li>(Real World Haskell argues that Show is good for serialization!)</li>
	    <li>Better served by other serialization libraries</li>
	  </ul>
	</section>

	<section id="show-3">
	  <h1>Display</h1>
	  <ul>
	    <li>Doesn't really make sense as an abstraction. Eg Parsec's
	      error messages: "unexpected ')', expected new line or end of
	      input"</li>
	    <li>Too many sensible implementations for some types, eg dates/times</li>
	    <li>Too easy to <code>show</code> the wrong thing</li>
	    <li>Impossible to change in a non-breaking way</li>
	    <li>Better served by individual functions</li>
	  </ul>
	</section>

	<section id="show-4">
	  <h1>Debugging / the repl</h1>
	  <ul>
	    <li>Lots of types don't have instances: <code>(-&gt;), IORef, IO</code></li>
	    <li>Poor display for large / complex values</li>
	    <li>No configurability in how printing is done</li>
	    <li>Better served by ...?</li>
	  </ul>
	</section>
	</section>

	<section id="debug-class">
	  <section id="debug-class-1">
	    <h1>A replacement for Show</h1>
	    <pre><code>class Debug a where
  debug :: a -&gt; Repr</code></pre>
	    <p>To recap, it should:</p>
	    <ul>
	      <li>explicitly only be for use in the repl and debugging</li>
	      <li>be possible to give every type of kind <code>Type</code> an instance</li>
	      <li>use a type with more structure than <code>String</code></li>
	      <li>allow us to perform configurable pretty-printing in the repl</li>
	    </ul>
	  </section>
	</section>
      </div>
    </div>

    <script type="text/javascript">
      Reveal.initialize({
	      history: true,
	    })
    </script>
  </body>
</html>
