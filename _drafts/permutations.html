---
layout: post
title: Permutations
---
<p>A colleague of mine severely nerd-sniped me at work recently with this rather innocuous-sounding challenge. I think it's a rather lovely little exercise and decided to write up my solution.</p>
<p>This post is designed to be read as a programming exercise. It will guide you along as it helps you break the problem into parts. If you want, you can skip to the end and read all the solutions (but that would be cheating).</p>
<p>Download the <a href="permutations.lhs">literate haskell source file</a> first; you can just fill in the gaps and then compile it like any other haskell file.</p>
<p>Consider the following shuffling technique:</p>
<ol style="list-style-type: decimal">
<li>Take one card from the top of the deck and discard it into a second pile.</li>
<li>Take another card from the top of the deck, and put it at the bottom of the deck.</li>
<li>Repeat these two steps, putting all discarded cards from step 1 into the same pile, until the original deck is all gone and the second pile has all the cards in it.</li>
</ol>
<p>For example, suppose we have a deck with 5 cards. The process looks like this:</p>
<p>{% include permutations/shuffle-viz.html %}</p>
<p>The problem is: how many shuffles does it take until a deck is in the same order as when you started, for a deck with an arbitrary number of cards?</p>
<p>We're going to use Haskell, because this is all about <em>functions</em> (in the mathematical sense), and so Haskell, being a <em>functional programming language</em>, is especially well suited to the job.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# OPTIONS_GHC -Wall #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.List</span> (sort, elemIndex)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Maybe</span> (catMaybes)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.Environment</span> (getArgs)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Test.QuickCheck</span></code></pre>
<p>A <code>Card</code> is just an <code>Int</code>, except that the type checker should ensure that we don't put a <code>Card</code> where an <code>Int</code> should go, or vice versa.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Card</span> <span class="fu">=</span> <span class="dt">Card</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>     <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Arbitrary</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; unCard ::</span> <span class="dt">Card</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> unCard (<span class="dt">Card</span> n) <span class="fu">=</span> n
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Card</span> <span class="kw">where</span>
<span class="ot">&gt;</span>     show <span class="fu">=</span> show <span class="fu">.</span> unCard</code></pre>
<p>We will represent a deck of cards just as a list. The head of the list will represent the top of the deck.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Deck</span> <span class="fu">=</span> [<span class="dt">Card</span>]
<span class="ot">&gt;</span> 
<span class="ot">&gt; unCardAll ::</span> <span class="dt">Deck</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
<span class="ot">&gt;</span> unCardAll <span class="fu">=</span> map unCard
<span class="ot">&gt;</span> 
<span class="ot">&gt; makeDeck ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Deck</span>
<span class="ot">&gt;</span> makeDeck n <span class="fu">=</span> map <span class="dt">Card</span> [<span class="dv">1</span><span class="fu">..</span>n]</code></pre>
<p>Our first job is to define a function that only performs steps 1 and 2 of the shuffle. What type should this function be? It should take a deck and a new pile, and return an updated deck and pile, so let's go with <code>(Deck, Deck) -&gt; (Deck, Deck)</code>.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; step ::</span> (<span class="dt">Deck</span>, <span class="dt">Deck</span>) <span class="ot">-&gt;</span> (<span class="dt">Deck</span>, <span class="dt">Deck</span>)
<span class="ot">&gt;</span> step (deck, pile) <span class="fu">=</span> <span class="kw">case</span> deck <span class="kw">of</span>
<span class="ot">&gt;</span>     a<span class="fu">:</span>b<span class="fu">:</span>cs <span class="ot">-&gt;</span> (cs <span class="fu">++</span> [b], a <span class="fu">:</span> pile)
<span class="ot">&gt;</span>     a<span class="fu">:</span>cs   <span class="ot">-&gt;</span> (cs, a <span class="fu">:</span> pile)
<span class="ot">&gt;</span>     []     <span class="ot">-&gt;</span> ([], pile)</code></pre>
<p>Now, we should think about what properties our <code>step</code> function should satisfy, so that we can get QuickCheck to test them for us. Here's one: after performing <code>step</code> n times on a deck, we should end up with the same number of cards that we started with:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_step_sameLength ::</span> <span class="dt">Deck</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_step_sameLength deck n&#39; <span class="fu">=</span>
<span class="ot">&gt;</span>     sumLength (times n step (deck, [])) <span class="fu">==</span> length deck
<span class="ot">&gt;</span>     <span class="kw">where</span>
<span class="ot">&gt;</span>     n <span class="fu">=</span> mod (length deck) abs n&#39;
<span class="ot">&gt;</span>     times m f z <span class="fu">=</span> iterate f z <span class="fu">!!</span> m
<span class="ot">&gt;</span>     sumLength (a, b) <span class="fu">=</span> length a <span class="fu">+</span> length b</code></pre>
<p>Here's another: after one step, we should have one fewer card in the deck (unless we started with an empty deck, in which case we should still have an empty deck)</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_step_oneFewer ::</span> <span class="dt">Deck</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_step_oneFewer deck <span class="fu">=</span>
<span class="ot">&gt;</span>     length (fst (step (deck, []))) <span class="fu">==</span> newLength deck
<span class="ot">&gt;</span>     <span class="kw">where</span>
<span class="ot">&gt;</span>     newLength [] <span class="fu">=</span> <span class="dv">0</span>
<span class="ot">&gt;</span>     newLength d <span class="fu">=</span> (length d) <span class="fu">-</span> <span class="dv">1</span></code></pre>
<p>Next we need to write a function that performs the shuffle on a deck. So we want <code>shuffle :: Deck -&gt; Deck</code>. Here are some Prelude functions that might come in handy:</p>
<ul>
<li><code>dropWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code>: drops elements from the front of a list until it finds an element that satisfies a predicate.</li>
<li><code>iterate :: (a -&gt; a) -&gt; a -&gt; [a]</code>: successively applies a function to a value, and returns all the intermediate values. So <code>iterate f x</code> is <code>[x, f x,   f (f x)...]</code></li>
</ul>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; first ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> first p <span class="fu">=</span> head <span class="fu">.</span> dropWhile (not <span class="fu">.</span> p)
<span class="ot">&gt;</span> 
<span class="ot">&gt; shuffle ::</span> <span class="dt">Deck</span> <span class="ot">-&gt;</span> <span class="dt">Deck</span>
<span class="ot">&gt;</span> shuffle d <span class="fu">=</span> snd <span class="fu">.</span> first (null <span class="fu">.</span> fst) <span class="fu">$</span> iterate step (d, [])</code></pre>
<p>More test properties: shuffling a deck should return another deck with the same number of cards:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_shuffle_sameLength ::</span> <span class="dt">Deck</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_shuffle_sameLength deck <span class="fu">=</span> length (shuffle deck) <span class="fu">==</span> length deck</code></pre>
<p>Shuffling a deck should move the top card to the bottom:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_shuffle_topToBottom ::</span> <span class="dt">Deck</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_shuffle_topToBottom [] <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span> prop_shuffle_topToBottom deck<span class="fu">@</span>(topCard<span class="fu">:</span>_) <span class="fu">=</span>
<span class="ot">&gt;</span>     last (shuffle deck) <span class="fu">==</span> topCard</code></pre>
<p>Next up is a function <code>order</code> which, given a function, gives us the number of times we have to apply it to a given value to get that value again.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; order ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> order f z <span class="fu">=</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">.</span> length <span class="fu">.</span> takeWhile (<span class="fu">/=</span> z) <span class="fu">.</span> drop <span class="dv">1</span> <span class="fu">$</span> iterate f z</code></pre>
<p>For our first attempt at answering the question, we can use a naive solution, which is just to keep shuffling the deck until we get the same deck again. We've got all the building blocks now, and we just need to put them together.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; f1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> f1 <span class="fu">=</span> order shuffle <span class="fu">.</span> makeDeck</code></pre>
<p>-- If we treat <code>shuffle</code> as a permutation in Sn, taking the initial position of -- a card in a deck size n to the position after one shuffle, we can hopefully -- glean the order more cleverly by decomposing to disjoint cycles. newtype Cycle = Cycle [Int] deriving (Eq, Ord)</p>
<p>rotate :: [a] -&gt; [a] rotate (x:xs) = xs ++ [x] rotate [] = []</p>
<p>-- Pass an infinte cycling list in; rotate until the smallest element is at -- the front; construct a Cycle. Smart constructor. makeCycle :: [Int] -&gt; Cycle makeCycle (x:xs) = let ys = x : takeWhile (/= x) xs h = minimum ys elems = first ((y:_) -&gt; y == h) (iterate rotate ys) in Cycle elems makeCycle [] = Cycle []</p>
<p>instance Show Cycle where show (Cycle xs) = &quot;(&quot; ++ join &quot; &quot; (map show xs) ++ &quot;)&quot; where join glue (y:ys) = y ++ (concatMap (glue ++) ys) join _ [] = &quot;&quot;</p>
<p>cycleLength :: Cycle -&gt; Int cycleLength (Cycle n) = length n</p>
<p>-- Calculate the shuffle permutation for a deck of size n. perm :: Int -&gt; [(Int, Int)] perm n = let initial = makeDeck n result = shuffle initial initial' = unCardAll initial result' = unCardAll result in catMaybes $ map (-&gt; fmap (-&gt; (x, idx + 1)) $ elemIndex x result') initial'</p>
<p>-- perm, but faster. perm' :: Int -&gt; [(Int, Int)] perm' n = go 0 (unCardAll . shuffle . makeDeck $ n) where go m (x:xs) = (x, m+1) : go (m+1) xs go _ [] = []</p>
<p>prop_perm_perm'<em>identical :: Int -&gt; Bool prop</em>perm_perm'_identical x = sort (perm x) == sort (perm' x)</p>
<p>-- Take a permutation as [(Int, Int)] and represent it as a product of disjoint -- cycles. decompose :: [(Int, Int)] -&gt; [Cycle] decompose xs = foldl f [] $ take (length xs) (iterate rotate xs) where f acc ys = let cyc = extractCycle ys in if cyc <code>elem</code> acc then acc else cyc : acc</p>
<p>-- Extract a single cycle from a permutation [(Int, Int)]. extractCycle :: [(Int, Int)] -&gt; Cycle extractCycle xs@(h:_) = makeCycle $ go h xs where go (y, pos) ys = case lookup pos ys of Just z -&gt; y : go (pos, z) ys Nothing -&gt; cycle [y, pos] extractCycle [] = makeCycle []</p>
<p>-- Find the lowest common multiple of a list. lcm' :: [Int] -&gt; Int lcm' = foldl lcm 1</p>
<p>-- 2nd attempt. f2 :: Int -&gt; Int f2 = lcm' . map cycleLength . decompose . perm'</p>
<p>prop_f1_f2_identical :: Int -&gt; Bool prop_f1_f2_identical x = f1 x == f2 x</p>
<p>-- Shrink the size of arbitrary things. This stops the test cases from running -- too long. sensible :: Testable a =&gt; a -&gt; Property sensible = mapSize (floor . logBase (2 :: Double) . fromIntegral)</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     args <span class="ot">&lt;-</span> getArgs
<span class="ot">&gt;</span>     <span class="kw">case</span> args <span class="kw">of</span>
<span class="ot">&gt;</span>         x<span class="fu">:</span>_ <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>             print <span class="fu">.</span> f2 <span class="fu">.</span> read <span class="fu">$</span> x
<span class="ot">&gt;</span>         _   <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>             <span class="co">-- check all of our properties, while shrinking the sizes</span>
<span class="ot">&gt;</span>             <span class="kw">let</span><span class="ot"> qc ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span>                 qc prop msg <span class="fu">=</span>
<span class="ot">&gt;</span>                     putStrLn (<span class="st">&quot;Testing: &quot;</span> <span class="fu">++</span> msg) <span class="fu">&gt;&gt;</span> quickCheck (sensible prop)
<span class="ot">&gt;</span>             qc prop_step_sameLength <span class="st">&quot;prop_step_sameLength&quot;</span>
<span class="ot">&gt;</span>             qc prop_step_oneFewer <span class="st">&quot;prop_step_oneFewer&quot;</span>
<span class="ot">&gt;</span>             qc prop_shuffle_sameLength <span class="st">&quot;prop_shuffle_sameLength&quot;</span>
<span class="ot">&gt;</span>             qc prop_shuffle_topToBottom <span class="st">&quot;prop_shuffle_topToBottom&quot;</span>
<span class="ot">&gt;</span>             qc prop_perm_perm&#39;_identical <span class="st">&quot;prop_perm_perm&#39;_identical&quot;</span>
<span class="ot">&gt;</span>             qc prop_f1_f2_identical <span class="st">&quot;prop_f1_f2_identical&quot;</span></code></pre>
