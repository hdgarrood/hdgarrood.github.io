---
layout: post
title: Permutations
---
<p>A colleague of mine severely nerd-sniped me at work recently with this rather innocuous-sounding challenge. I think it's a rather lovely little exercise and decided to write up my solution.</p>
<p>This post is designed to be read as a programming exercise. It will guide you along as it helps you break the problem into parts. If you want, you can skip to the end and read all the solutions (but that would be cheating).</p>
<p>Download the <a href="permutations.lhs">literate haskell source file</a> first; you can just fill in the gaps and then compile it like any other haskell file.</p>
<p>Consider the following shuffling technique:</p>
<ol style="list-style-type: decimal">
<li>Take one card from the top of the deck and discard it into a second pile.</li>
<li>Take another card from the top of the deck, and put it at the bottom of the deck.</li>
<li>Repeat these two steps, putting all discarded cards from step 1 into the same pile, until the original deck is all gone and the second pile has all the cards in it.</li>
</ol>
<p>For example, suppose we have a deck with 5 cards. The process looks like this:</p>
<p>{% include permutations/shuffle-viz.html %}</p>
<p>The problem is: how many shuffles does it take until a deck is in the same order as when you started, for a deck with an arbitrary number of cards?</p>
<p>We're going to use Haskell, because this is all about <em>functions</em> (in the mathematical sense), and so Haskell, being a <em>functional programming language</em>, is especially well suited to the job.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="ot">{-# OPTIONS_GHC -Wall #-}</span>
<span class="ot">&gt;</span> <span class="ot">{-# LANGUAGE GeneralizedNewtypeDeriving #-}</span>
<span class="ot">&gt;</span> <span class="kw">module</span> <span class="dt">Main</span> <span class="kw">where</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.List</span> (sort, elemIndex)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Data.Maybe</span> (catMaybes)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">System.Environment</span> (getArgs)
<span class="ot">&gt;</span> <span class="kw">import </span><span class="dt">Test.QuickCheck</span></code></pre>
<p>A <code>Card</code> is just an <code>Int</code>, except that the type checker should ensure that we don't put a <code>Card</code> where an <code>Int</code> should go, or vice versa.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Card</span> <span class="fu">=</span> <span class="dt">Card</span> <span class="dt">Int</span>
<span class="ot">&gt;</span>     <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Arbitrary</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; unCard ::</span> <span class="dt">Card</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> unCard (<span class="dt">Card</span> n) <span class="fu">=</span> n
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Card</span> <span class="kw">where</span>
<span class="ot">&gt;</span>     show <span class="fu">=</span> show <span class="fu">.</span> unCard</code></pre>
<p>We will represent a deck of cards just as a list. The head of the list will represent the top of the deck.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">Deck</span> <span class="fu">=</span> [<span class="dt">Card</span>]
<span class="ot">&gt;</span> 
<span class="ot">&gt; unCardAll ::</span> <span class="dt">Deck</span> <span class="ot">-&gt;</span> [<span class="dt">Int</span>]
<span class="ot">&gt;</span> unCardAll <span class="fu">=</span> map unCard
<span class="ot">&gt;</span> 
<span class="ot">&gt; makeDeck ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Deck</span>
<span class="ot">&gt;</span> makeDeck n <span class="fu">=</span> map <span class="dt">Card</span> [<span class="dv">1</span><span class="fu">..</span>n]</code></pre>
<p>Our first job is to define a function that only performs steps 1 and 2 of the shuffle. What type should this function be? It should take a deck and a new pile, and return an updated deck and pile, so let's go with <code>(Deck, Deck) -&gt; (Deck, Deck)</code>.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; step ::</span> (<span class="dt">Deck</span>, <span class="dt">Deck</span>) <span class="ot">-&gt;</span> (<span class="dt">Deck</span>, <span class="dt">Deck</span>)
<span class="ot">&gt;</span> step (deck, pile) <span class="fu">=</span> <span class="kw">case</span> deck <span class="kw">of</span>
<span class="ot">&gt;</span>     a<span class="fu">:</span>b<span class="fu">:</span>cs <span class="ot">-&gt;</span> (cs <span class="fu">++</span> [b], a <span class="fu">:</span> pile)
<span class="ot">&gt;</span>     a<span class="fu">:</span>cs   <span class="ot">-&gt;</span> (cs, a <span class="fu">:</span> pile)
<span class="ot">&gt;</span>     []     <span class="ot">-&gt;</span> ([], pile)</code></pre>
<p>Now, we should think about what properties our <code>step</code> function should satisfy, so that we can get QuickCheck to test them for us. Here's one: after performing <code>step</code> n times on a deck, we should end up with the same number of cards that we started with:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_step_sameLength ::</span> <span class="dt">Deck</span> <span class="ot">-&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_step_sameLength deck n&#39; <span class="fu">=</span>
<span class="ot">&gt;</span>     sumLength (times n step (deck, [])) <span class="fu">==</span> length deck
<span class="ot">&gt;</span>     <span class="kw">where</span>
<span class="ot">&gt;</span>     n <span class="fu">=</span> (abs n&#39;) <span class="ot">`mod`</span> (length deck <span class="fu">+</span> <span class="dv">1</span>)
<span class="ot">&gt;</span>     times m f z <span class="fu">=</span> iterate f z <span class="fu">!!</span> m
<span class="ot">&gt;</span>     sumLength (a, b) <span class="fu">=</span> length a <span class="fu">+</span> length b</code></pre>
<p>Here's another: after one step, we should have one fewer card in the deck (unless we started with an empty deck, in which case we should still have an empty deck)</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_step_oneFewer ::</span> <span class="dt">Deck</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_step_oneFewer deck <span class="fu">=</span>
<span class="ot">&gt;</span>     length (fst (step (deck, []))) <span class="fu">==</span> newLength deck
<span class="ot">&gt;</span>     <span class="kw">where</span>
<span class="ot">&gt;</span>     newLength [] <span class="fu">=</span> <span class="dv">0</span>
<span class="ot">&gt;</span>     newLength d <span class="fu">=</span> (length d) <span class="fu">-</span> <span class="dv">1</span></code></pre>
<p>Next we need to write a function that performs the shuffle on a deck. So we want <code>shuffle :: Deck -&gt; Deck</code>. Here are some Prelude functions that might come in handy:</p>
<ul>
<li><code>dropWhile :: (a -&gt; Bool) -&gt; [a] -&gt; [a]</code>: drops elements from the front of a list until it finds an element that satisfies a predicate.</li>
<li><code>iterate :: (a -&gt; a) -&gt; a -&gt; [a]</code>: successively applies a function to a value, and returns all the intermediate values. So <code>iterate f x</code> is <code>[x, f x,   f (f x)...]</code></li>
</ul>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; first ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a
<span class="ot">&gt;</span> first p <span class="fu">=</span> head <span class="fu">.</span> dropWhile (not <span class="fu">.</span> p)
<span class="ot">&gt;</span> 
<span class="ot">&gt; shuffle ::</span> <span class="dt">Deck</span> <span class="ot">-&gt;</span> <span class="dt">Deck</span>
<span class="ot">&gt;</span> shuffle d <span class="fu">=</span> snd <span class="fu">.</span> first (null <span class="fu">.</span> fst) <span class="fu">$</span> iterate step (d, [])</code></pre>
<p>More test properties: shuffling a deck should return another deck with the same number of cards:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_shuffle_sameLength ::</span> <span class="dt">Deck</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_shuffle_sameLength deck <span class="fu">=</span> length (shuffle deck) <span class="fu">==</span> length deck</code></pre>
<p>Shuffling a deck should move the top card to the bottom:</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; prop_shuffle_topToBottom ::</span> <span class="dt">Deck</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_shuffle_topToBottom [] <span class="fu">=</span> <span class="dt">True</span>
<span class="ot">&gt;</span> prop_shuffle_topToBottom deck<span class="fu">@</span>(topCard<span class="fu">:</span>_) <span class="fu">=</span>
<span class="ot">&gt;</span>     last (shuffle deck) <span class="fu">==</span> topCard</code></pre>
<p>Next up is a function <code>order</code> which, given a function, gives us the number of times we have to apply it to a given value to get that value again.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; order ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> order f z <span class="fu">=</span> (<span class="fu">+</span><span class="dv">1</span>) <span class="fu">.</span> length <span class="fu">.</span> takeWhile (<span class="fu">/=</span> z) <span class="fu">.</span> drop <span class="dv">1</span> <span class="fu">$</span> iterate f z</code></pre>
<p>For our first attempt at answering the question, we can use a naive solution, which is just to keep shuffling the deck until we get the same deck again. We've got all the building blocks now, and we just need to put them together.</p>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; f1 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> f1 <span class="fu">=</span> order shuffle <span class="fu">.</span> makeDeck</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="co">-- If we treat `shuffle` as a permutation in Sn, taking the initial position of</span>
<span class="ot">&gt;</span> <span class="co">-- a card in a deck size n to the position after one shuffle, we can hopefully</span>
<span class="ot">&gt;</span> <span class="co">-- glean the order more cleverly by decomposing to disjoint cycles.</span>
<span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Cycle</span> <span class="fu">=</span> <span class="dt">Cycle</span> [<span class="dt">Int</span>]
<span class="ot">&gt;</span>     <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>)
<span class="ot">&gt;</span> 
<span class="ot">&gt; rotate ::</span> [a] <span class="ot">-&gt;</span> [a]
<span class="ot">&gt;</span> rotate (x<span class="fu">:</span>xs) <span class="fu">=</span> xs <span class="fu">++</span> [x]
<span class="ot">&gt;</span> rotate [] <span class="fu">=</span> []
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- Pass an infinte cycling list in; rotate until the smallest element is at</span>
<span class="ot">&gt;</span> <span class="co">-- the front; construct a Cycle. Smart constructor.</span>
<span class="ot">&gt; makeCycle ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Cycle</span>
<span class="ot">&gt;</span> makeCycle (x<span class="fu">:</span>xs) <span class="fu">=</span>
<span class="ot">&gt;</span>     <span class="kw">let</span> ys    <span class="fu">=</span> x <span class="fu">:</span> takeWhile (<span class="fu">/=</span> x) xs
<span class="ot">&gt;</span>         h     <span class="fu">=</span> minimum ys
<span class="ot">&gt;</span>         elems <span class="fu">=</span> first (\(y<span class="fu">:</span>_) <span class="ot">-&gt;</span> y <span class="fu">==</span> h) (iterate rotate ys)
<span class="ot">&gt;</span>     <span class="kw">in</span>  <span class="dt">Cycle</span> elems
<span class="ot">&gt;</span> makeCycle [] <span class="fu">=</span> <span class="dt">Cycle</span> []
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">Cycle</span> <span class="kw">where</span>
<span class="ot">&gt;</span>     show (<span class="dt">Cycle</span> xs) <span class="fu">=</span> <span class="st">&quot;(&quot;</span> <span class="fu">++</span> join <span class="st">&quot; &quot;</span> (map show xs) <span class="fu">++</span> <span class="st">&quot;)&quot;</span>
<span class="ot">&gt;</span>         <span class="kw">where</span>
<span class="ot">&gt;</span>         join glue (y<span class="fu">:</span>ys) <span class="fu">=</span> y <span class="fu">++</span> (concatMap (glue <span class="fu">++</span>) ys)
<span class="ot">&gt;</span>         join _ [] <span class="fu">=</span> <span class="st">&quot;&quot;</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt; cycleLength ::</span> <span class="dt">Cycle</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> cycleLength (<span class="dt">Cycle</span> n) <span class="fu">=</span> length n
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- Calculate the shuffle permutation for a deck of size n.</span>
<span class="ot">&gt; perm ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]
<span class="ot">&gt;</span> perm n <span class="fu">=</span>
<span class="ot">&gt;</span>     <span class="kw">let</span> initial <span class="fu">=</span> makeDeck n
<span class="ot">&gt;</span>         result <span class="fu">=</span> shuffle initial
<span class="ot">&gt;</span>         initial&#39; <span class="fu">=</span> unCardAll initial
<span class="ot">&gt;</span>         result&#39; <span class="fu">=</span> unCardAll result
<span class="ot">&gt;</span>     <span class="kw">in</span> catMaybes <span class="fu">$</span> map (\x <span class="ot">-&gt;</span>
<span class="ot">&gt;</span>         fmap (\idx <span class="ot">-&gt;</span> (x, idx <span class="fu">+</span> <span class="dv">1</span>)) <span class="fu">$</span> elemIndex x result&#39;) initial&#39;
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- perm, but faster.</span>
<span class="ot">&gt; perm&#39; ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)]
<span class="ot">&gt;</span> perm&#39; n <span class="fu">=</span> go <span class="dv">0</span> (unCardAll <span class="fu">.</span> shuffle <span class="fu">.</span> makeDeck <span class="fu">$</span> n)
<span class="ot">&gt;</span>     <span class="kw">where</span> go m (x<span class="fu">:</span>xs) <span class="fu">=</span> (x, m<span class="fu">+</span><span class="dv">1</span>) <span class="fu">:</span> go (m<span class="fu">+</span><span class="dv">1</span>) xs
<span class="ot">&gt;</span>           go _ [] <span class="fu">=</span> []
<span class="ot">&gt;</span> 
<span class="ot">&gt; prop_perm_perm&#39;_identical ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_perm_perm&#39;_identical x <span class="fu">=</span> sort (perm x) <span class="fu">==</span> sort (perm&#39; x)
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- Take a permutation as [(Int, Int)] and represent it as a product of disjoint</span>
<span class="ot">&gt;</span> <span class="co">-- cycles.</span>
<span class="ot">&gt; decompose ::</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)] <span class="ot">-&gt;</span> [<span class="dt">Cycle</span>]
<span class="ot">&gt;</span> decompose xs <span class="fu">=</span> foldl f [] <span class="fu">$</span> take (length xs) (iterate rotate xs)
<span class="ot">&gt;</span>     <span class="kw">where</span>
<span class="ot">&gt;</span>     f acc ys <span class="fu">=</span>
<span class="ot">&gt;</span>         <span class="kw">let</span> cyc <span class="fu">=</span> extractCycle ys
<span class="ot">&gt;</span>         <span class="kw">in</span> <span class="kw">if</span> cyc <span class="ot">`elem`</span> acc
<span class="ot">&gt;</span>             <span class="kw">then</span> acc
<span class="ot">&gt;</span>             <span class="kw">else</span> cyc <span class="fu">:</span> acc
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- Extract a single cycle from a permutation [(Int, Int)].</span>
<span class="ot">&gt; extractCycle ::</span> [(<span class="dt">Int</span>, <span class="dt">Int</span>)] <span class="ot">-&gt;</span> <span class="dt">Cycle</span>
<span class="ot">&gt;</span> extractCycle xs<span class="fu">@</span>(h<span class="fu">:</span>_) <span class="fu">=</span> makeCycle <span class="fu">$</span> go h xs
<span class="ot">&gt;</span>     <span class="kw">where</span>
<span class="ot">&gt;</span>     go (y, pos) ys <span class="fu">=</span> <span class="kw">case</span> lookup pos ys <span class="kw">of</span>
<span class="ot">&gt;</span>         <span class="dt">Just</span> z <span class="ot">-&gt;</span> y <span class="fu">:</span> go (pos, z) ys
<span class="ot">&gt;</span>         <span class="dt">Nothing</span> <span class="ot">-&gt;</span> cycle [y, pos]
<span class="ot">&gt;</span> extractCycle [] <span class="fu">=</span> makeCycle []
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- Find the lowest common multiple of a list.</span>
<span class="ot">&gt; lcm&#39; ::</span> [<span class="dt">Int</span>] <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> lcm&#39; <span class="fu">=</span> foldl lcm <span class="dv">1</span>
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- 2nd attempt.</span>
<span class="ot">&gt; f2 ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span>
<span class="ot">&gt;</span> f2 <span class="fu">=</span> lcm&#39; <span class="fu">.</span> map cycleLength <span class="fu">.</span> decompose <span class="fu">.</span> perm&#39;
<span class="ot">&gt;</span> 
<span class="ot">&gt; prop_f1_f2_identical ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> prop_f1_f2_identical x <span class="fu">=</span> f1 x <span class="fu">==</span> f2 x
<span class="ot">&gt;</span> 
<span class="ot">&gt;</span> <span class="co">-- Shrink the size of arbitrary things. This stops the test cases from running</span>
<span class="ot">&gt;</span> <span class="co">-- too long.</span>
<span class="ot">&gt; sensible ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Property</span>
<span class="ot">&gt;</span> sensible <span class="fu">=</span> mapSize (floor <span class="fu">.</span> logBase (<span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Double</span>) <span class="fu">.</span> fromIntegral)</code></pre>
<pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; main ::</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span> main <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>     args <span class="ot">&lt;-</span> getArgs
<span class="ot">&gt;</span>     <span class="kw">case</span> args <span class="kw">of</span>
<span class="ot">&gt;</span>         x<span class="fu">:</span>_ <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>             print <span class="fu">.</span> f2 <span class="fu">.</span> read <span class="fu">$</span> x
<span class="ot">&gt;</span>         _   <span class="ot">-&gt;</span> <span class="kw">do</span>
<span class="ot">&gt;</span>             <span class="co">-- check all of our properties, while shrinking the sizes</span>
<span class="ot">&gt;</span>             <span class="kw">let</span><span class="ot"> qc ::</span> <span class="dt">Testable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">IO</span> ()
<span class="ot">&gt;</span>                 qc prop msg <span class="fu">=</span>
<span class="ot">&gt;</span>                     putStrLn (<span class="st">&quot;Testing: &quot;</span> <span class="fu">++</span> msg) <span class="fu">&gt;&gt;</span> quickCheck (sensible prop)
<span class="ot">&gt;</span>             qc prop_step_sameLength <span class="st">&quot;prop_step_sameLength&quot;</span>
<span class="ot">&gt;</span>             qc prop_step_oneFewer <span class="st">&quot;prop_step_oneFewer&quot;</span>
<span class="ot">&gt;</span>             qc prop_shuffle_sameLength <span class="st">&quot;prop_shuffle_sameLength&quot;</span>
<span class="ot">&gt;</span>             qc prop_shuffle_topToBottom <span class="st">&quot;prop_shuffle_topToBottom&quot;</span>
<span class="ot">&gt;</span>             qc prop_perm_perm&#39;_identical <span class="st">&quot;prop_perm_perm&#39;_identical&quot;</span>
<span class="ot">&gt;</span>             qc prop_f1_f2_identical <span class="st">&quot;prop_f1_f2_identical&quot;</span></code></pre>
